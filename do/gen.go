package do

import (
	"bufio"
	"fmt"
	"go-tools/java2go/gen"
	"go-tools/java2go/internal/match"
	"go-tools/java2go/internal/strs"
	"io"
	"os"
	"path/filepath"
	"strings"
)

const (
	version = "1.0.0"
)

// A Generator represents the state of a single Go source file
// being scanned for generator commands.
type Generator struct {
	r        io.Reader
	path     string // full rooted path name.
	dir      string // full rooted directory of file.
	file     string // base name of file.
	target   string
	goo      string
	pkg      string
	commands map[string][]string
	lineNum  int // current line number.
	env      []string
}

type EntField struct {
	Name    string
	Comment string
	Typ     string
}

// run runs the generators in the current file.
func (g *Generator) run() (ok bool) {
	// Processing below here calls g.errorf on failure, which does panic(stop).
	// If we encounter an error, we abort the package.
	defer func() {
		e := recover()
		if e != nil {
			ok = false
			if e != stop {
				panic(e)
			}
		}
	}()
	g.dir, g.file = filepath.Split(g.path)
	g.dir = filepath.Clean(g.dir) // No final separator please.
	g.target = strs.JSONSnakeCase(strings.Replace(strings.Replace(g.file, "DO", "", -1), "java", "go", -1))
	if g.goo == "" {
		g.goo = "./"
	}

	// 检查路径是否存在
	if _, err := os.Stat(g.goo); os.IsNotExist(err) {
		fmt.Println("目标目录并不存在：" + g.goo)
		return false
	}

	// 组合路径和文件名
	filepath := filepath.Join(g.goo, g.target)
	// 检查文件是否存在
	if _, err := os.Stat(filepath); err == nil || os.IsExist(err) {
		fmt.Println("文件已经存在：" + filepath + "， 如要更新先删除")
		return false
	}
	// Scan for lines that start "//go:generate".
	// Can't use bufio.Scanner because it can't handle long lines,
	// which are likely to appear when using generate.
	input := bufio.NewReader(g.r)
	var err error
	// One line per loop.
	file := gen.NewGeneratedFile()
	g.header(file)

	var field *EntField = nil
	for {
		g.lineNum++ // 1-indexed.
		var buf []byte
		buf, err = input.ReadSlice('\n')
		if err != nil {
			// Check for marker at EOF without final \n.
			if err == io.EOF {
				err = io.ErrUnexpectedEOF
			}
			break
		}

		if strings.HasPrefix(string(buf), "@ApiModel") {
			file.ApiModel = match.FindDoubleQuotes(string(buf))
		} else if strings.HasPrefix(string(buf), "@TableName") {
			file.StructName = strs.GoCamelCase(strings.Replace(match.FindDoubleQuote(string(buf)), "\"", "", -1))
		} else if strings.HasPrefix(string(buf), "public class ") {
			g.structer(file)
			//file.StructName = "asd"
		} else if strings.Contains(string(buf), "@TableId") {
			file.P("\t\tfield.Int64(\"id\").Comment(\"id\"),")
			field = nil
		} else if strings.Contains(string(buf), "@ApiModelProperty") {
			field = new(EntField)
			field.Comment = match.FindDoubleQuote(string(buf))
		} else if strings.Contains(string(buf), "@TableField") {
			if field == nil {
				continue
			}
			field.Name = match.FindDoubleQuote(string(buf))
		} else if strings.Contains(string(buf), "private ") {
			if field == nil {
				continue
			}
			if strings.Contains(string(buf), "Integer") {
				field.Typ = "Int32"
				g.field(file, field)
				field = nil
			} else if strings.Contains(string(buf), "String") {
				field.Typ = "String"
				g.field(file, field)
				field = nil
			} else if strings.Contains(string(buf), "Long") {
				field.Typ = "Int64"
				g.field(file, field)
				field = nil
			} else if strings.Contains(string(buf), "Float") {
				field.Typ = "Float32"
				g.field(file, field)
				field = nil
			} else if strings.Contains(string(buf), "Double") {
				field.Typ = "Float"
				g.field(file, field)
				field = nil
			} else if strings.Contains(string(buf), "private Date") {
				if strings.Contains(string(buf), "createTime;") {
					field = nil
					continue
				} else if strings.Contains(string(buf), "updateTime;") {
					field = nil
					continue
				} else {
					field.Typ = "Time"
					g.field(file, field)
					field = nil
				}
			} else {
				fmt.Println("暂不支持的类型：" + string(buf))
				field = nil
				continue
			}
		}
	}
	//if err != nil && err != io.EOF {
	//	g.errorf("error reading %s: %s", ShortPath(g.path), err)
	//}

	field = new(EntField)
	field.Comment = "创建时间"
	field.Name = "\"created_at\""
	field.Typ = "Time"
	g.field(file, field)

	field.Comment = "修改时间"
	field.Name = "\"updated_at\""
	field.Typ = "Time"
	g.field(file, field)

	field.Comment = "删除"
	field.Name = "\"deleted_at\""
	field.Typ = "Time"
	g.field(file, field)
	file.P("\t}")
	file.P("}")
	file.P("")

	err = file.WriteFile(filepath)
	if err != nil {
		fmt.Println(err)
	}
	return true
}

func (g *Generator) header(file *gen.GeneratedFile) {
	file.P("// Code generated by j2g. DO NOT EDIT.")
	file.P("// versions:")
	file.P("// - j2g v", version)
	file.P("package schema                       ")
	file.P("                                     ")
	file.P("import (")
	file.P("\t\"time\"")
	file.P("")
	file.P("\t\"entgo.io/ent\"")
	file.P("\t\"entgo.io/ent/dialect\"")
	file.P("\t\"entgo.io/ent/schema/field\"")
	file.P(")")
	file.P("")
}

func (g *Generator) structer(file *gen.GeneratedFile) {
	if len(file.ApiModel) > 0 {
		comment := file.ApiModel[0]
		for index := 1; index < len(file.ApiModel); index++ {
			comment += ", " + file.ApiModel[index]
		}
		file.P("// " + comment)
	}
	file.P("// " + file.StructName + " holds the schema definition for the " + file.StructName + " entity.")
	file.P("type " + file.StructName + " struct {")
	file.P("\tent.Schema")
	file.P("}")
	file.P("")
	file.P("// Fields of the " + file.StructName + ".")
	file.P("func (" + file.StructName + ") Fields() []ent.Field {")
	file.P("\treturn []ent.Field{")
}

func (g *Generator) field(file *gen.GeneratedFile, field *EntField) {
	if field.Name == "" {
		return
	}
	if field.Typ == "Int32" {
		file.P("\t\tfield." + field.Typ + "(" + field.Name + ").Default(0).Comment(" + field.Comment + "),")
	} else if field.Typ == "Int64" {
		file.P("\t\tfield." + field.Typ + "(" + field.Name + ").Default(0).Comment(" + field.Comment + "),")
	} else if field.Typ == "Float32" { // 32bit
		file.P("\t\tfield." + field.Typ + "(" + field.Name + ").Default(0).Comment(" + field.Comment + "),")
	} else if field.Typ == "Float" { // 64bit
		file.P("\t\tfield." + field.Typ + "(" + field.Name + ").Default(0).Comment(" + field.Comment + "),")
	} else if field.Typ == "String" {
		file.P("\t\tfield." + field.Typ + "(" + field.Name + ").Default(\"\").Comment(" + field.Comment + "),")
	} else if field.Typ == "Time" {
		if field.Name == "created_at" {
			file.P("\t\tfield." + field.Typ + "(" + field.Name + ").")
			file.P("\t\t\tDefault(time.Now).SchemaType(map[string]string{")
			file.P("\t\t\tdialect.MySQL:  \"datetime\",")
			file.P("\t\t\tdialect.SQLite: \"datetime\",")
			file.P("\t\t}),")
		} else if field.Name == "updated_at" {
			file.P("\t\tfield." + field.Typ + "(" + field.Name + ").")
			file.P("\t\t\tDefault(time.Now).SchemaType(map[string]string{")
			file.P("\t\t\tdialect.MySQL:  \"datetime\",")
			file.P("\t\t\tdialect.SQLite: \"datetime\",")
			file.P("\t\t}),")
		} else {
			file.P("\t\tfield." + field.Typ + "(" + field.Name + ").")
			file.P("\t\t\tOptional().Nillable().")
			file.P("\t\t\tSchemaType(map[string]string{")
			file.P("\t\t\t\tdialect.MySQL:  \"datetime\",")
			file.P("\t\t\t\tdialect.SQLite: \"datetime\",")
			file.P("\t\t\t}),")
		}
	}
}
